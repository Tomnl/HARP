# For some reason need to re-import PyQt4...... Not the best solution but seems to work
from PyQt4 import QtGui, QtCore
import sys
import subprocess
import os, signal
import re
import pickle
import pprint
import time
import shutil
import uuid
from multiprocessing import Process


from Progress import Ui_Progress


class Progress(QtGui.QDialog):
    '''
    Class to provide the dialog box to monitor current Image processing jobs.
    Basically extend the QDialog class (from Progress.py) generated by QT Designer
    '''

    # Create a constructor
    def __init__(self,configOb):
        print "Progress has started"
        self.threadPool = []
        super(Progress, self).__init__()
        self.ui=Ui_Progress()
        self.ui.setupUi(self)
        self.show()
        self.configOb = configOb
        self.value = 0

        self.ui.label_1.setText(configOb.full_name)

        self.thread(configOb)

        self.ui.pushButtonCancel_1.clicked.connect(self.cancel)

    def cancel(self):
        self.close()

    def addMore(self):
        dir = os.path.dirname(os.path.abspath(__file__))
        runPro_p = subprocess.Popen(["python", dir+"/Main.py"],stdout=subprocess.PIPE, stderr=subprocess.PIPE)


    def add(self,test):
        self.ui.label1_tracking.setText(test)

        if test == "Processing finished" :
            self.ui.progressBar_1.setValue(100)

        if test == "Crop finished" :
            self.ui.progressBar_1.setValue(50)

        print test
        value = 0

#         print self.value
#         while not test == "Processing finished":
#             print "while loop started"
#             print "loop",value
#             time.sleep(0.1)
#             QtCore.QCoreApplication.processEvents()
#             value = self.ui.progressBar_1.value() + 1
#
#             if test == "Processing finished" :
#                  self.ui.progressBar_1.setValue(100)
#                  break
#             if (self.value == 100):
#                  break
#             self.ui.progressBar_1.setValue(value)
#             QtGui.qApp.processEvents()


    def thread(self,configOb):
        self.threadPool = []
        self.threadPool.append( WorkThread(configOb) )
        self.connect( self.threadPool[len(self.threadPool)-1], QtCore.SIGNAL("update(QString)"), self.add )
        self.threadPool[len(self.threadPool)-1].start()

    def closeEvent(self, event):
        """ Function doc """
        reply = QtGui.QMessageBox.question(self,  'Message',  'Are you sure to quit?',  QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
            self.threadPool[len(self.threadPool)-1].exit()
            #self.threadPool[len(self.threadPool)-1].terminate()
            self.pid_log_path = os.path.join(self.configOb.meta_path,self.configOb.full_name+"_pid.log")
            ins = open( self.pid_log_path, "r" )
            for line in ins:
                print int(line)
                try :
                    os.kill(int(line),signal.SIGKILL)
                except OSError as e:
                    print("os.kill could not kill process, reason: {0}".format(e))


        else:
            event.ignore()


class WorkThread(QtCore.QThread):
    def __init__(self,configOb):
        QtCore.QThread.__init__(self)
        self.configOb = configOb

    def __del__(self):
        self.wait()

    def run(self):
        self.emit( QtCore.SIGNAL('update(QString)'), "Started Processing" )
        # Get the directory of the script
        self.dir = os.path.dirname(os.path.realpath(__file__))
        # Get the session log file
        self.session_log_path = os.path.join(self.configOb.meta_path,self.configOb.full_name+"_session.log")
        self.pid_log_path = os.path.join(self.configOb.meta_path,self.configOb.full_name+"_pid.log")

        # Save as object to print to
        session = open(self.session_log_path, 'w+')
        session_pid = open(self.pid_log_path, 'w+')

        session.write("Name of recon:"+self.configOb.full_name+"\n")

        ###############################################
        # Cropping
        ###############################################
        # Make crop folder
        # get cropped path from config object (shorten it so it is easier to read)
        cropped_path = self.configOb.cropped_path

        if not os.path.exists(cropped_path):
            os.makedirs(cropped_path)

        crop_run = os.path.join(self.dir, "autocrop.py")
        print crop_run
        if self.configOb.crop_option == "Manual" :
            session.write("########################Performing manual crop########################\n")
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing manual crop" )

            manpro = subprocess.Popen(["python", crop_run,"-i",self.configOb.input_folder,"-o",
                         cropped_path, "-t", "tif","-d",self.configOb.xcrop, self.configOb.ycrop, self.configOb.wcrop, self.configOb.hcrop],
                            stdout=session, stderr=session)
            session_pid.write(str(manpro.pid)+"\n")
            session_pid.close()
            manpro.communicate()
            self.emit( QtCore.SIGNAL('update(QString)'), "Crop finished" )
            session.write("########################Crop finished########################\n")

        # Perform the automatic crop if required
        if self.configOb.crop_option == "Automatic" :
            session.write("########################Performing autocrop########################\n")
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing autocrop" )

            aupro = subprocess.Popen(["python", crop_run,"-i",self.configOb.input_folder,"-o", cropped_path, "-t", "tif"],
                            stdout=session, stderr=session)
            session_pid.write(str(aupro.pid)+"\n")
            session_pid.close()
            aupro.communicate()
            self.emit( QtCore.SIGNAL('update(QString)'), "Crop finished" )
            session.write("########################Crop finished########################\n")

        # Do not perform any crop as user specified
        if self.configOb.crop_option == "None" :
            self.emit( QtCore.SIGNAL('update(QString)'), "No Crop carried out" )
            print "No crop carried out"
            session.write("No crop carried out\n")
            session_pid.close()

        ###############################################
        # Copying of other files from recon directory
        ###############################################
        session.write("Copying other files from recon\n")
        for file in os.listdir(self.configOb.input_folder):
            suffix_txt, suffix_spr, suffix_log, suffix_crv = ".txt","spr",".log",".crv"
            if file.endswith((".txt",".log",".crv")) or re.search('spr', file, re.IGNORECASE):
                session.write("File"+file+"\n")
                file = os.path.join(self.configOb.input_folder,file)
                shutil.copy(file,cropped_path)

        ###############################################
        # Compression
        ###############################################
        #subprocess.call(["tar", "-cjf" check.tar.bz2 test
         #                   stdout=session, stderr=session)
        #self.emit( QtCore.SIGNAL('update(QString)'), "Crop finished" )


        ###############################################
        # Scaling
        ###############################################

        # First make subfolder for scaled stacks
        if not os.path.exists(self.configOb.scale_path):
            os.makedirs(self.configOb.scale_path)

        # Perform scaling as subprocess with Popen (they should be done in the background)
        if self.configOb.SF2 == "yes" :
            proSF2 = self.executeImagej(":0.5:x2",session_pid,session)
            out2, err2 = proSF2.communicate()

        if self.configOb.SF3 == "yes" :
            proSF3 = self.executeImagej(":0.3333:x3",session_pid,session)
            out3, err3 = proSF3.communicate()

        if self.configOb.SF4 == "yes" :
            proSF4 = self.executeImagej(":0.25:x4",session_pid,session)
            out4, err4 = proSF4.communicate()

        session.close()
        self.emit( QtCore.SIGNAL('update(QString)'), "Processing finished" )


    def executeImagej(self, scaleFactor,session_pid,session):
        '''
        @param: str, scaleFactor eg ":0.5"
        '''
        # for saving pid again
        session_pid = open(self.pid_log_path, 'a+')
        self.emit( QtCore.SIGNAL('update(QString)'), "Performing scaling ({})".format(scaleFactor) )
        process = subprocess.Popen(["java", "-jar", "/usr/share/java/ij.jar", "-batch", os.path.join(self.dir, "siah_scale.txt"),
                                    self.configOb.imageJ + scaleFactor],stdout=session,stderr=session)
        session_pid.write(str(process.pid)+"\n")
        session_pid.close()
        return process

def main():
    app = QtGui.QApplication(sys.argv)
    ex = Progress(configOb)
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
