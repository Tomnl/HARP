from PyQt4 import QtGui, QtCore
import sys
import subprocess
import os, signal
import re
import pickle
import pprint
import time
import shutil
import uuid
import logging
import logging.handlers
import tarfile
import autocrop
from multiprocessing import freeze_support

from sys import platform as _platform

from Progress import Ui_Progress


class Progress(QtGui.QDialog):
    '''
    Class to provide the dialog box to monitor current Image processing jobs.
    Basically extend the QDialog class (from Progress.py) generated by QT Designer
    '''

    # Create a constructor
    def __init__(self,configOb):
        print "Progress has started"
        self.threadPool = []
        super(Progress, self).__init__()
        self.ui=Ui_Progress()
        self.ui.setupUi(self)
        self.show()
        self.configOb = configOb
        self.value = 0

        self.ui.label_1.setText(configOb.full_name)

        self.thread(configOb)

        self.ui.pushButtonCancel_1.clicked.connect(self.cancel)
        self.ui.pushButtonAddMore.clicked.connect(self.addMore)

    def cancel(self):
        self.close()

    def addMore(self):
        # Just starts up HARP again.
        dir = os.path.dirname(os.path.abspath(__file__))
        #The following regex distinguishes between running from a executable and a from a script
        regex = re.compile("dist")
        print dir
        if regex.search(dir):
            runPro_p = subprocess.Popen([os.path.join(dir,"Main.exe")],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print "started new HARP exe program"
        else :
            runPro_p = subprocess.Popen(["python", os.path.join(dir,"Main.py")],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print "started new HARP python program"

    def add(self,test):
        self.ui.label1_tracking.setText(test)

        if test == "Processing finished" :
            self.ui.progressBar_1.setValue(100)

        if test == "Crop finished" :
            self.ui.progressBar_1.setValue(50)

        if test == "Error" :
            self.threadPool[len(self.threadPool)-1].terminate()

        print test
        value = 0

#         print self.value
#         while not test == "Processing finished":
#             print "while loop started"
#             print "loop",value
#             time.sleep(0.1)
#             QtCore.QCoreApplication.processEvents()
#             value = self.ui.progressBar_1.value() + 1
#
#             if test == "Processing finished" :
#                  self.ui.progressBar_1.setValue(100)
#                  break
#             if (self.value == 100):
#                  break
#             self.ui.progressBar_1.setValue(value)
#             QtGui.qApp.processEvents()


    def thread(self,configOb):
        self.threadPool = []
        self.threadPool.append( WorkThread(configOb) )
        self.connect( self.threadPool[len(self.threadPool)-1], QtCore.SIGNAL("update(QString)"), self.add )
        self.threadPool[len(self.threadPool)-1].start()

    def closeEvent(self, event):
        """ Function doc """
        reply = QtGui.QMessageBox.question(self,  'Message',  'Are you sure to quit?',  QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)
        logging.info("****Shutting down program****")


        if reply == QtGui.QMessageBox.Yes:
            event.accept()
            self.threadPool[len(self.threadPool)-1].terminate()

            self.pid_log_path = os.path.join(self.configOb.meta_path,"pid.log")
            ins = open( self.pid_log_path, "r" )
            for line in ins:

                try :
                    if _platform == "linux" or _platform == "linux2":
                        os.kill(int(line),signal.SIGKILL)
                        print "killed:", line
                        logging.info("killed:", line)
                    elif _platform == "win32" or _platform == "win64":
                        line = line.rstrip()
                        proc = subprocess.Popen(["taskkill", "/f", "/t", "/im",str(line)], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        (out, err) = proc.communicate()
                        if out:
                            logging.info(out)
                            print "program output:", out
                        if err:
                            logging.info(err)
                            print "program error output:", err

                except OSError as e:
                    print("os.kill could not kill process, reason: {0}".format(e))
                    logging.info("os.kill could not kill process, reason: {0}".format(e))
                    message = QtGui.QMessageBox.warning(self, "Message", "os.kill could not kill process, reason: {0}".format(e))

            logging.info("****HARP has shutdown ****")
            logging.shutdown()

        else:
            event.ignore()


class WorkThread(QtCore.QThread):
    def __init__(self,configOb):
        QtCore.QThread.__init__(self)
        self.configOb = configOb


    def __del__(self):
        self.wait()

    def run(self):
        logging.info("########################################")
        logging.info("### Main processing                  ###")
        logging.info("########################################")

        self.emit( QtCore.SIGNAL('update(QString)'), "Started Processing" )
        # Get the directory of the script
        self.dir = os.path.dirname(os.path.realpath(__file__))

        # Get the session log files
        self.session_log_path = os.path.join(self.configOb.meta_path,"session.log")
        self.pid_log_path = os.path.join(self.configOb.meta_path,"pid.log")
        self.scale_log_path = os.path.join(self.configOb.meta_path,"scale.log")

        # Save as object to print to
        if os.path.exists(self.session_log_path):
            os.remove(self.session_log_path)

        logging.info("Creating files")
        #session = open(self.session_log_path, 'w+')
        session_pid = open(self.pid_log_path, 'w+')
        session_scale = open(self.scale_log_path, 'w+')

        ###############################################
        # Copy temp files (pre-processing log and zprojection image)
        ###############################################
        logging.info("Copy temp files")
        if self.configOb.crop_option == "Manual" :
            if os.path.exists(os.path.join(self.configOb.tmp_dir,"max_intensity_z.tif")):
                shutil.copyfile(os.path.join(self.configOb.tmp_dir,"max_intensity_z.tif"), os.path.join(self.configOb.meta_path,"max_intensity_z.tif"))

        shutil.copyfile(os.path.join(self.configOb.tmp_dir,"session.log"), os.path.join(self.configOb.meta_path,"session.log"))

        ###############################################
        # Update logging settings, to save too processed recon diretory
        ###############################################
        logging.info("update logger location")
        f = logging.Formatter(fmt='%(asctime)s %(message)s')
        handlers = logging.handlers.RotatingFileHandler(self.session_log_path,
                                                         maxBytes=100000, backupCount=1)
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.DEBUG)
        handlers.setFormatter(f)
        handlers.setLevel(logging.DEBUG)
        root_logger.addHandler(handlers)



        ###############################################
        # Cropping
        ###############################################
        # Make crop folder
        # get cropped path from config object (shorten it so it is easier to read)
        logging.info("*****Performing cropping******")
        cropped_path = self.configOb.cropped_path

        if not os.path.exists(cropped_path):
            os.makedirs(cropped_path)

        crop_run = os.path.join(self.dir, "autocrop.py")
        print crop_run
        if self.configOb.crop_option == "Manual" :
            logging.info("manual crop")
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing manual crop" )
            dimensions_tuple = (int(self.configOb.xcrop), int(self.configOb.ycrop), int(self.configOb.wcrop), int(self.configOb.hcrop))
            print dimensions_tuple
            crop_result = autocrop.run(self.configOb.input_folder,cropped_path,def_crop=dimensions_tuple)
            if crop_result :
                logging.info("Error in cropping see below:")
                logging.info(crop_result)
                self.emit( QtCore.SIGNAL('update(QString)'), "Cropping Error, see session log file")
                return


#             manpro = subprocess.Popen(["python", crop_run,"-i",self.configOb.input_folder,"-o",
#                          cropped_path, "-t", "tif","-d",self.configOb.xcrop, self.configOb.ycrop, self.configOb.wcrop, self.configOb.hcrop],
#                             stdout=session_crop, stderr=session_crop)
#             session_pid.write(str(manpro.pid)+"\n")
#             session_pid.close()
#             manpro.communicate()
            self.emit( QtCore.SIGNAL('update(QString)'), "Crop finished" )
            logging.info("Crop finished")

        # Perform the automatic crop if required
        if self.configOb.crop_option == "Automatic" :
            logging.info("autocrop")
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing autocrop" )

            crop_result = autocrop.run(self.configOb.input_folder,cropped_path)

            if crop_result :
                logging.info("Error in cropping see below:")
                logging.info(crop_result)
                self.emit( QtCore.SIGNAL('update(QString)'), "Cropping Error, see session log file")
                return

            self.emit( QtCore.SIGNAL('update(QString)'), "Crop finished" )
            logging.info("Crop finished")

        # Do not perform any crop as user specified
        if self.configOb.crop_option == "None" :
            self.emit( QtCore.SIGNAL('update(QString)'), "No Crop carried out" )
            print "No crop carried out"
            logging.info("No crop carried out")
            session_pid.close()

        ###############################################
        # Copying of other files from recon directory
        ###############################################
        logging.info("Copying other files from recon")
        for file in os.listdir(self.configOb.input_folder):
            suffix_txt, suffix_spr, suffix_log, suffix_crv = ".txt","spr",".log",".crv"
            if file.endswith((".txt",".log",".crv")) or re.search('spr', file, re.IGNORECASE):
                logging.info("File copied:"+file)
                file = os.path.join(self.configOb.input_folder,file)
                shutil.copy(file,cropped_path)

        ###############################################
        # Compression
        ###############################################
        if self.configOb.scans_recon_comp == "yes" or self.configOb.crop_comp == "yes" :
            logging.info("***Performing Compression***")

        if self.configOb.scans_recon_comp == "yes" :
            if self.configOb.scan_folder:
                self.emit( QtCore.SIGNAL('update(QString)'), "Performing compression of scan folder" )
                logging.info("Compression of scan folder")
                path_scan,folder_name_scan = os.path.split(self.configOb.scan_folder)

                out = tarfile.open(str(self.configOb.scan_folder)+".tar.bz2", mode='w:bz2')
                out.add(path_scan, arcname="TarName")
                out.close()
                self.emit( QtCore.SIGNAL('update(QString)'), "Compression of scan folder finished" )

            self.emit( QtCore.SIGNAL('update(QString)'), "Performing compression of original recon folder" )
            logging.info("Compression of original recon folder")
            path_scan,folder_name_scan = os.path.split(self.configOb.input_folder)

            out = tarfile.open(str(self.configOb.input_folder)+".tar.bz2", mode='w:bz2')
            out.add(path_scan, arcname="TarName")
            out.close()
            self.emit( QtCore.SIGNAL('update(QString)'), "Compression of recon folder finished" )

        if  self.configOb.crop_comp == "yes":
            if self.configOb.crop_option != "No_crop":
                self.emit( QtCore.SIGNAL('update(QString)'), "Compression of cropped recon started" )
                out = tarfile.open(cropped_path+".tar.bz2", mode='w:bz2')
                out.add(self.configOb.output_folder, arcname="TarName")
                out.close()

        ###############################################
        # Scaling
        ###############################################
        logging.info("*****Performing scaling******")
        # First make subfolder for scaled stacks
        if not os.path.exists(self.configOb.scale_path):
            os.makedirs(self.configOb.scale_path)

        # Perform scaling as subprocess with Popen (they should be done in the background)
        if self.configOb.SF2 == "yes" :
            proSF2 = self.executeImagej("^0.5^x2^",session_pid,session_scale,"2")

        if self.configOb.SF3 == "yes" :
            proSF3 = self.executeImagej("^0.3333^x3^",session_pid,session_scale,"3")

        if self.configOb.SF4 == "yes" :
            proSF4 = self.executeImagej("^0.25^x4^",session_pid,session_scale,"4")

        if self.configOb.SF5 == "yes" :
            proSF5 = self.executeImagej("^0.2^x5^",session_pid,session_scale,"5")

        if self.configOb.SF6 == "yes" :
            proSF6 = self.executeImagej("^0.1667^x6^",session_pid,session_scale,"6")

        if self.configOb.pixel_option == "yes" :
            propixel = self.executeImagej("^"+str(self.configOb.SF_pixel)+"^x"+str(self.configOb.SFX_pixel)+"^",session_pid,session_scale,"Pixel")




        session_scale.close()
        self.emit( QtCore.SIGNAL('update(QString)'), "Processing finished" )
        session_pid.close()
        # Presume processes finished so clear PID file
        open(self.pid_log_path, 'w').close()

        session_scale.close()
        logging.info("Processing finished")
        logging.info("########################################")




    def executeImagej(self, scaleFactor,session_pid,session_scale,sf):
        '''
        @param: str, scaleFactor eg ":0.5"
        '''
        # for saving pid again
        session_pid = open(self.pid_log_path, 'a+')
        if (self.configOb.recon_pixel_size) and sf != "Pixel":
            new_pixel = float(self.configOb.recon_pixel_size)*float(sf)
            new_pixel = str(round(new_pixel,4))
        elif self.configOb.pixel_option == "yes" :
            new_pixel = self.configOb.user_specified_pixel
        else :
            new_pixel = "NA"

        if _platform == "linux" or _platform == "linux2":

            logging.info("Scale by factor:")
            logging.info(str(sf))
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing scaling ({})".format(str(sf)) )

            process = subprocess.Popen(["java", "-jar", "/usr/share/java/ij.jar", "-batch", os.path.join(self.dir, "siah_scale.txt"),
                                    self.configOb.imageJ+ scaleFactor + "^" +new_pixel],stdout=session_scale,stderr=session_scale)
            session_pid.write(str(process.pid)+"\n")
            session_pid.close()
            out, err = process.communicate()

            logging.info("Finished scaling")

        elif _platform == "win32" or _platform == "win64":

            logging.info("Scale by factor:")
            logging.info(str(sf))
            self.emit( QtCore.SIGNAL('update(QString)'), "Performing scaling ({})".format(str(sf)) )
            ijpath = os.path.join('c:', os.sep, 'Program Files', 'ImageJ', 'ij.jar')
            process = subprocess.Popen(["java", "-jar", ijpath, "-batch", os.path.join(self.dir, "siah_scale.txt"),
                                    self.configOb.imageJ + scaleFactor + "^" +new_pixel],stdout=session_scale,stderr=session_scale)
            session_pid.write(str(process.pid)+"\n")
            session_pid.close()
            out, err = process.communicate()
            logging.info("Finished scaling")








def main():
    app = QtGui.QApplication(sys.argv)
    ex = Progress(configOb)
    sys.exit(app.exec_())


if __name__ == "__main__":
    freeze_support()
    main()
